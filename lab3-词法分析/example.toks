INT	int	1	0
ID	test_hexoct	1	3	0x55561378e1a8
LPAREN	(	1	14
RPAREN	)	1	15
LBRACE	{	1	16
INT	int	2	0
ID	a	2	3	0x55561378e1d0
COMMA	,	2	4
ID	b	2	5	0x55561378e1f8
SEMICOLON	;	2	6
ID	a	3	0	0x55561378e1d0
ASSIGN	=	3	1
HEXADECIMAL	0xf0aC	3	2	61612
SEMICOLON	;	3	8
ID	b	4	0	0x55561378e1f8
ASSIGN	=	4	1
HEXADECIMAL	0XcBeF	4	2	52207
SEMICOLON	;	4	8
RETURN	return	5	0
ID	a	5	6	0x55561378e1d0
ADD	+	5	7
ID	b	5	8	0x55561378e1f8
ADD	+	5	9
OCTAL	075	5	10	61
SEMICOLON	;	5	13
RBRACE	}	6	0
VOID	void	9	0
ID	test_float	9	4	0x55561378e220
LPAREN	(	9	14
RPAREN	)	9	15
LBRACE	{	9	16
CONST	const	11	0
FLOAT	float	11	5
ID	RADIUS	11	10	0x55561378e248
ASSIGN	=	11	16
FLOAT	5.5	11	17	5.500000
COMMA	,	11	20
ID	PI	11	21	0x55561378e270
ASSIGN	=	11	23
FLOAT	03.141592653589793	11	24	3.141593
COMMA	,	11	42
ID	EPS	11	43	0x55561378e298
ASSIGN	=	11	46
FLOAT	1e-6	11	47	0.000001
SEMICOLON	;	11	51
FLOAT	float	12	0
ID	FACT	12	5	0x55561378e2c0
ASSIGN	=	12	9
SUB	-	12	10
FLOAT	.33E+5	12	11	33000.000000
SEMICOLON	;	12	17
CONST	const	14	0
FLOAT	float	14	5
ID	PI_HEX	14	10	0x55561378e2e8
ASSIGN	=	14	16
FLOAT_HEXADECIMAL	0x1.921fb6p+1	14	17	3.141593
COMMA	,	14	30
ID	HEX2	14	31	0x55561378e310
ASSIGN	=	14	35
FLOAT_HEXADECIMAL	0X.AP-3	14	36	0.078125
SEMICOLON	;	14	43
RBRACE	}	15	0
VOID	void	18	0
ID	test_annotation	18	4	0x55561378e338
LPAREN	(	18	19
RPAREN	)	18	20
LBRACE	{	18	21
INT	int	19	0
ID	f	19	3	0x55561378e360
COMMA	,	19	4
ID	g	19	5	0x55561378e388
COMMA	,	19	6
ID	h	19	7	0x55561378e3b0
SEMICOLON	;	19	8
ID	f	21	0	0x55561378e360
ASSIGN	=	21	1
ID	g	21	2	0x55561378e388
DIV	/	21	3
ID	h	21	4	0x55561378e3b0
SEMICOLON	;	21	5
ID	f	22	0	0x55561378e360
ASSIGN	=	22	1
ID	g	22	2	0x55561378e388
MOD	%	22	3
ID	h	22	4	0x55561378e3b0
SEMICOLON	;	22	5
ID	f	23	0	0x55561378e360
ASSIGN	=	23	1
ID	g	23	2	0x55561378e388
ADD	+	24	0
ID	h	24	1	0x55561378e3b0
SEMICOLON	;	24	2
ID	f	25	0	0x55561378e360
ASSIGN	=	25	1
ID	g	25	2	0x55561378e388
MUL	*	25	3
ID	h	25	4	0x55561378e3b0
MUL	*	25	5
DIV	/	25	6
RBRACE	}	26	0
VOID	void	29	0
ID	test_terminal	29	4	0x55561378e3d8
LPAREN	(	29	17
RPAREN	)	29	18
LBRACE	{	29	19
CONST	const	30	0
INT	int	30	5
ID	arr	30	8	0x55561378e400
LBRACKET	[	30	11
DECIMAL	5	30	12	5
RBRACKET	]	30	13
ASSIGN	=	30	14
LBRACE	{	30	15
DECIMAL	0	30	16	0
COMMA	,	30	17
DECIMAL	1	30	18	1
COMMA	,	30	19
DECIMAL	2	30	20	2
COMMA	,	30	21
DECIMAL	3	30	22	3
COMMA	,	30	23
DECIMAL	4	30	24	4
RBRACE	}	30	25
SEMICOLON	;	30	26
INT	int	31	0
ID	a	31	3	0x55561378e1d0
ASSIGN	=	31	4
LPAREN	(	31	5
ID	arr	31	6	0x55561378e400
LBRACKET	[	31	9
DECIMAL	1	31	10	1
RBRACKET	]	31	11
ADD	+	31	12
DECIMAL	2	31	13	2
RPAREN	)	31	14
MUL	*	31	15
DECIMAL	3	31	16	3
DIV	/	31	17
DECIMAL	4	31	18	4
SUB	-	31	19
DECIMAL	5	31	20	5
MOD	%	31	21
DECIMAL	2	31	22	2
SEMICOLON	;	31	23
INT	int	32	0
ID	b	32	3	0x55561378e1f8
COMMA	,	32	4
ID	c	32	5	0x55561378e428
COMMA	,	32	6
ID	d	32	7	0x55561378e450
SEMICOLON	;	32	8
WHILE	while	33	0
LPAREN	(	33	5
ID	a	33	6	0x55561378e1d0
LESS	<	33	7
DECIMAL	75	33	8	75
RPAREN	)	33	10
LBRACE	{	33	11
ID	b	34	0	0x55561378e1f8
ASSIGN	=	34	1
DECIMAL	42	34	2	42
SEMICOLON	;	34	4
IF	if	35	0
LPAREN	(	35	2
ID	a	35	3	0x55561378e1d0
LEQUAL	<=	35	4
DECIMAL	99	35	6	99
RPAREN	)	35	8
LBRACE	{	35	9
ID	c	36	0	0x55561378e428
ASSIGN	=	36	1
ID	b	36	2	0x55561378e1f8
MUL	*	36	3
DECIMAL	2	36	4	2
SEMICOLON	;	36	5
IF	if	37	0
LPAREN	(	37	2
DECIMAL	1	37	3	1
EQUAL	==	37	4
DECIMAL	1	37	6	1
RPAREN	)	37	7
LBRACE	{	37	8
ID	a	38	0	0x55561378e1d0
ASSIGN	=	38	1
ID	c	38	2	0x55561378e428
MUL	*	38	3
DECIMAL	2	38	4	2
SEMICOLON	;	38	5
BREAK	break	39	0
SEMICOLON	;	39	5
RBRACE	}	40	0
RBRACE	}	41	0
RBRACE	}	42	0
ID	d	43	0	0x55561378e450
ASSIGN	=	43	1
SUB	-	43	2
DECIMAL	2	43	3	2
SEMICOLON	;	43	4
IF	if	44	0
LPAREN	(	44	2
NOT	!	44	3
LPAREN	(	44	4
LPAREN	(	44	5
ID	d	44	6	0x55561378e450
MUL	*	44	7
DECIMAL	1	44	8	1
DIV	/	44	9
DECIMAL	2	44	10	2
RPAREN	)	44	11
GREATER	>	44	12
DECIMAL	0	44	13	0
OR	||	44	14
LPAREN	(	44	16
ID	a	44	17	0x55561378e1d0
SUB	-	44	18
ID	b	44	19	0x55561378e1f8
RPAREN	)	44	20
GEQUAL	>=	44	21
DECIMAL	0	44	23	0
RPAREN	)	44	24
AND	&&	44	25
LPAREN	(	44	27
ID	c	44	28	0x55561378e428
ADD	+	44	29
DECIMAL	3	44	30	3
RPAREN	)	44	31
MOD	%	44	32
DECIMAL	2	44	33	2
NEQUAL	!=	44	34
DECIMAL	0	44	36	0
RPAREN	)	44	37
LBRACE	{	44	38
ID	putint	45	0	0x55561378e478
LPAREN	(	45	6
ID	d	45	7	0x55561378e450
RPAREN	)	45	8
SEMICOLON	;	45	9
RBRACE	}	46	0
RBRACE	}	47	0
INT	int	50	0
ID	k	50	3	0x55561378e4a0
SEMICOLON	;	50	4
VOID	void	51	0
ID	test_scope	51	4	0x55561378e4c8
LPAREN	(	51	14
RPAREN	)	51	15
LBRACE	{	51	16
ID	k	52	0	0x55561378e4a0
ASSIGN	=	52	1
DECIMAL	3389	52	2	3389
SEMICOLON	;	52	6
IF	if	53	0
LPAREN	(	53	2
ID	k	53	3	0x55561378e4a0
LESS	<	53	4
DECIMAL	10000	53	5	10000
RPAREN	)	53	10
LBRACE	{	53	11
ID	k	54	0	0x55561378e4a0
ASSIGN	=	54	1
ID	k	54	2	0x55561378e4a0
ADD	+	54	3
DECIMAL	1	54	4	1
SEMICOLON	;	54	5
INT	int	55	0
ID	k	55	3	0x55561378e4a0
ASSIGN	=	55	4
DECIMAL	112	55	5	112
SEMICOLON	;	55	8
ID	k	56	0	0x55561378e4a0
ASSIGN	=	56	1
ID	k	56	2	0x55561378e4a0
SUB	-	56	3
DECIMAL	88	56	4	88
SEMICOLON	;	56	6
RBRACE	}	57	0
ID	putint	58	0	0x55561378e478
LPAREN	(	58	6
ID	k	58	7	0x55561378e4a0
RPAREN	)	58	8
SEMICOLON	;	58	9
RBRACE	}	59	0
