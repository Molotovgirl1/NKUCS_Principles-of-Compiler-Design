CONST	const	2	0
INT	int	2	5
ID	W	2	8	0x55aa57d341a8
ASSIGN	=	2	9
DECIMAL	192	2	10	192
COMMA	,	2	13
ID	H	2	14	0x55aa57d341d0
ASSIGN	=	2	15
DECIMAL	192	2	16	192
COMMA	,	2	19
ID	N	2	20	0x55aa57d341f8
ASSIGN	=	2	21
DECIMAL	24	2	22	24
SEMICOLON	;	2	24
CONST	const	4	0
FLOAT	float	4	5
ID	PI	4	10	0x55aa57d34220
ASSIGN	=	4	12
FLOAT	3.14159265359	4	13	3.141593
COMMA	,	4	26
ID	TWO_PI	4	27	0x55aa57d34248
ASSIGN	=	4	33
FLOAT	6.28318530718	4	34	6.283185
SEMICOLON	;	4	47
CONST	const	5	0
INT	int	5	5
ID	MAX_STEP	5	8	0x55aa57d34270
ASSIGN	=	5	16
DECIMAL	10	5	17	10
SEMICOLON	;	5	19
CONST	const	6	0
FLOAT	float	6	5
ID	MAX_DISTANCE	6	10	0x55aa57d34298
ASSIGN	=	6	22
FLOAT	2.0	6	23	2.000000
SEMICOLON	;	6	26
CONST	const	7	0
FLOAT	float	7	5
ID	EPSILON	7	10	0x55aa57d342c0
ASSIGN	=	7	17
FLOAT	1e-6	7	18	0.000001
SEMICOLON	;	7	22
CONST	const	9	0
INT	int	9	5
ID	RAND_MAX	9	8	0x55aa57d342e8
ASSIGN	=	9	16
DECIMAL	100000007	9	17	100000007
SUB	-	9	26
DECIMAL	1	9	27	1
SEMICOLON	;	9	28
INT	int	10	0
ID	seed	10	3	0x55aa57d34310
ASSIGN	=	10	7
DECIMAL	0	10	8	0
SEMICOLON	;	10	9
INT	int	12	0
ID	rand	12	3	0x55aa57d34338
LPAREN	(	12	7
RPAREN	)	12	8
LBRACE	{	12	9
ID	seed	13	0	0x55aa57d34310
ASSIGN	=	13	4
LPAREN	(	13	5
ID	seed	13	6	0x55aa57d34310
MUL	*	13	10
DECIMAL	19980130	13	11	19980130
ADD	+	13	19
DECIMAL	23333	13	20	23333
RPAREN	)	13	25
MOD	%	13	26
DECIMAL	100000007	13	27	100000007
SEMICOLON	;	13	36
IF	if	14	0
LPAREN	(	14	2
ID	seed	14	3	0x55aa57d34310
LESS	<	14	7
DECIMAL	0	14	8	0
RPAREN	)	14	9
ID	seed	14	10	0x55aa57d34310
ASSIGN	=	14	14
ID	seed	14	15	0x55aa57d34310
ADD	+	14	19
DECIMAL	100000007	14	20	100000007
SEMICOLON	;	14	29
RETURN	return	15	0
ID	seed	15	6	0x55aa57d34310
SEMICOLON	;	15	10
RBRACE	}	16	0
FLOAT	float	18	0
ID	my_fabs	18	5	0x55aa57d34360
LPAREN	(	18	12
FLOAT	float	18	13
ID	x	18	18	0x55aa57d34388
RPAREN	)	18	19
LBRACE	{	18	20
IF	if	19	0
LPAREN	(	19	2
ID	x	19	3	0x55aa57d34388
GREATER	>	19	4
DECIMAL	0	19	5	0
RPAREN	)	19	6
RETURN	return	19	7
ID	x	19	13	0x55aa57d34388
SEMICOLON	;	19	14
RETURN	return	20	0
SUB	-	20	6
ID	x	20	7	0x55aa57d34388
SEMICOLON	;	20	8
RBRACE	}	21	0
FLOAT	float	23	0
ID	my_sqrt	23	5	0x55aa57d343b0
LPAREN	(	23	12
FLOAT	float	23	13
ID	x	23	18	0x55aa57d34388
RPAREN	)	23	19
LBRACE	{	23	20
FLOAT	float	24	0
ID	t	24	5	0x55aa57d343d8
ASSIGN	=	24	6
ID	x	24	7	0x55aa57d34388
DIV	/	24	8
DECIMAL	8	24	9	8
ADD	+	24	10
FLOAT	0.5	24	11	0.500000
ADD	+	24	14
DECIMAL	2	24	15	2
MUL	*	24	16
ID	x	24	17	0x55aa57d34388
DIV	/	24	18
LPAREN	(	24	19
DECIMAL	4	24	20	4
ADD	+	24	21
ID	x	24	22	0x55aa57d34388
RPAREN	)	24	23
SEMICOLON	;	24	24
INT	int	25	0
ID	c	25	3	0x55aa57d34400
ASSIGN	=	25	4
DECIMAL	10	25	5	10
SEMICOLON	;	25	7
WHILE	while	26	0
LPAREN	(	26	5
ID	c	26	6	0x55aa57d34400
RPAREN	)	26	7
LBRACE	{	26	8
ID	t	27	0	0x55aa57d343d8
ASSIGN	=	27	1
LPAREN	(	27	2
ID	t	27	3	0x55aa57d343d8
ADD	+	27	4
ID	x	27	5	0x55aa57d34388
DIV	/	27	6
ID	t	27	7	0x55aa57d343d8
RPAREN	)	27	8
DIV	/	27	9
DECIMAL	2	27	10	2
SEMICOLON	;	27	11
ID	c	28	0	0x55aa57d34400
ASSIGN	=	28	1
ID	c	28	2	0x55aa57d34400
SUB	-	28	3
DECIMAL	1	28	4	1
SEMICOLON	;	28	5
RBRACE	}	29	0
RETURN	return	30	0
ID	t	30	6	0x55aa57d343d8
SEMICOLON	;	30	7
RBRACE	}	31	0
FLOAT	float	33	0
ID	p	33	5	0x55aa57d34428
LPAREN	(	33	6
FLOAT	float	33	7
ID	x	33	12	0x55aa57d34388
RPAREN	)	33	13
LBRACE	{	33	14
RETURN	return	33	15
DECIMAL	3	33	21	3
MUL	*	33	22
ID	x	33	23	0x55aa57d34388
SUB	-	33	24
DECIMAL	4	33	25	4
MUL	*	33	26
ID	x	33	27	0x55aa57d34388
MUL	*	33	28
ID	x	33	29	0x55aa57d34388
MUL	*	33	30
ID	x	33	31	0x55aa57d34388
SEMICOLON	;	33	32
RBRACE	}	33	33
FLOAT	float	35	0
ID	my_sin_impl	35	5	0x55aa57d34450
LPAREN	(	35	16
FLOAT	float	35	17
ID	x	35	22	0x55aa57d34388
RPAREN	)	35	23
LBRACE	{	35	24
IF	if	36	0
LPAREN	(	36	2
ID	my_fabs	36	3	0x55aa57d34360
LPAREN	(	36	10
ID	x	36	11	0x55aa57d34388
RPAREN	)	36	12
LEQUAL	<=	36	13
ID	EPSILON	36	15	0x55aa57d342c0
RPAREN	)	36	22
RETURN	return	36	23
ID	x	36	29	0x55aa57d34388
SEMICOLON	;	36	30
RETURN	return	37	0
ID	p	37	6	0x55aa57d34428
LPAREN	(	37	7
ID	my_sin_impl	37	8	0x55aa57d34450
LPAREN	(	37	19
ID	x	37	20	0x55aa57d34388
DIV	/	37	21
FLOAT	3.0	37	22	3.000000
RPAREN	)	37	25
RPAREN	)	37	26
SEMICOLON	;	37	27
RBRACE	}	38	0
FLOAT	float	40	0
ID	my_sin	40	5	0x55aa57d34478
LPAREN	(	40	11
FLOAT	float	40	12
ID	x	40	17	0x55aa57d34388
RPAREN	)	40	18
LBRACE	{	40	19
IF	if	41	0
LPAREN	(	41	2
ID	x	41	3	0x55aa57d34388
GREATER	>	41	4
ID	TWO_PI	41	5	0x55aa57d34248
OR	||	41	11
ID	x	41	13	0x55aa57d34388
LESS	<	41	14
SUB	-	41	15
ID	TWO_PI	41	16	0x55aa57d34248
RPAREN	)	41	22
LBRACE	{	41	23
INT	int	42	0
ID	xx	42	3	0x55aa57d344a0
ASSIGN	=	42	5
ID	x	42	6	0x55aa57d34388
DIV	/	42	7
ID	TWO_PI	42	8	0x55aa57d34248
SEMICOLON	;	42	14
ID	x	43	0	0x55aa57d34388
ASSIGN	=	43	1
ID	x	43	2	0x55aa57d34388
SUB	-	43	3
ID	xx	43	4	0x55aa57d344a0
MUL	*	43	6
ID	TWO_PI	43	7	0x55aa57d34248
SEMICOLON	;	43	13
RBRACE	}	44	0
IF	if	45	0
LPAREN	(	45	2
ID	x	45	3	0x55aa57d34388
GREATER	>	45	4
ID	PI	45	5	0x55aa57d34220
RPAREN	)	45	7
ID	x	45	8	0x55aa57d34388
ASSIGN	=	45	9
ID	x	45	10	0x55aa57d34388
SUB	-	45	11
ID	TWO_PI	45	12	0x55aa57d34248
SEMICOLON	;	45	18
IF	if	46	0
LPAREN	(	46	2
ID	x	46	3	0x55aa57d34388
LESS	<	46	4
SUB	-	46	5
ID	PI	46	6	0x55aa57d34220
RPAREN	)	46	8
ID	x	46	9	0x55aa57d34388
ASSIGN	=	46	10
ID	x	46	11	0x55aa57d34388
ADD	+	46	12
ID	TWO_PI	46	13	0x55aa57d34248
SEMICOLON	;	46	19
RETURN	return	47	0
ID	my_sin_impl	47	6	0x55aa57d34450
LPAREN	(	47	17
ID	x	47	18	0x55aa57d34388
RPAREN	)	47	19
SEMICOLON	;	47	20
RBRACE	}	48	0
FLOAT	float	50	0
ID	my_cos	50	5	0x55aa57d344c8
LPAREN	(	50	11
FLOAT	float	50	12
ID	x	50	17	0x55aa57d34388
RPAREN	)	50	18
LBRACE	{	50	19
RETURN	return	50	20
ID	my_sin	50	26	0x55aa57d34478
LPAREN	(	50	32
ID	x	50	33	0x55aa57d34388
ADD	+	50	34
ID	PI	50	35	0x55aa57d34220
DIV	/	50	37
DECIMAL	2	50	38	2
RPAREN	)	50	39
SEMICOLON	;	50	40
RBRACE	}	50	41
FLOAT	float	52	0
ID	circle_sdf	52	5	0x55aa57d344f0
LPAREN	(	52	15
FLOAT	float	52	16
ID	x	52	21	0x55aa57d34388
COMMA	,	52	22
FLOAT	float	52	23
ID	y	52	28	0x55aa57d34518
COMMA	,	52	29
FLOAT	float	52	30
ID	cx	52	35	0x55aa57d34540
COMMA	,	52	37
FLOAT	float	52	38
ID	cy	52	43	0x55aa57d34568
COMMA	,	52	45
FLOAT	float	52	46
ID	r	52	51	0x55aa57d34590
RPAREN	)	52	52
LBRACE	{	52	53
FLOAT	float	53	0
ID	ux	53	5	0x55aa57d345b8
ASSIGN	=	53	7
ID	x	53	8	0x55aa57d34388
SUB	-	53	9
ID	cx	53	10	0x55aa57d34540
COMMA	,	53	12
ID	uy	53	13	0x55aa57d345e0
ASSIGN	=	53	15
ID	y	53	16	0x55aa57d34518
SUB	-	53	17
ID	cy	53	18	0x55aa57d34568
SEMICOLON	;	53	20
RETURN	return	54	0
ID	my_sqrt	54	6	0x55aa57d343b0
LPAREN	(	54	13
ID	ux	54	14	0x55aa57d345b8
MUL	*	54	16
ID	ux	54	17	0x55aa57d345b8
ADD	+	54	19
ID	uy	54	20	0x55aa57d345e0
MUL	*	54	22
ID	uy	54	23	0x55aa57d345e0
RPAREN	)	54	25
SUB	-	54	26
ID	r	54	27	0x55aa57d34590
SEMICOLON	;	54	28
RBRACE	}	55	0
VOID	void	57	0
ID	scene	57	4	0x55aa57d34608
LPAREN	(	57	9
FLOAT	float	57	10
ID	x	57	15	0x55aa57d34388
COMMA	,	57	16
FLOAT	float	57	17
ID	y	57	22	0x55aa57d34518
COMMA	,	57	23
FLOAT	float	57	24
ID	ret	57	29	0x55aa57d34630
LBRACKET	[	57	32
RBRACKET	]	57	33
RPAREN	)	57	34
LBRACE	{	57	35
FLOAT	float	58	0
ID	sd0	58	5	0x55aa57d34658
ASSIGN	=	58	8
ID	circle_sdf	58	9	0x55aa57d344f0
LPAREN	(	58	19
ID	x	58	20	0x55aa57d34388
COMMA	,	58	21
ID	y	58	22	0x55aa57d34518
COMMA	,	58	23
FLOAT	0.4	58	24	0.400000
COMMA	,	58	27
FLOAT	0.4	58	28	0.400000
COMMA	,	58	31
FLOAT	0.10	58	32	0.100000
RPAREN	)	58	36
COMMA	,	58	37
ID	sd1	59	0	0x55aa57d34680
ASSIGN	=	59	3
ID	circle_sdf	59	4	0x55aa57d344f0
LPAREN	(	59	14
ID	x	59	15	0x55aa57d34388
COMMA	,	59	16
ID	y	59	17	0x55aa57d34518
COMMA	,	59	18
FLOAT	0.6	59	19	0.600000
COMMA	,	59	22
FLOAT	0.6	59	23	0.600000
COMMA	,	59	26
FLOAT	0.05	59	27	0.050000
RPAREN	)	59	31
SEMICOLON	;	59	32
IF	if	60	0
LPAREN	(	60	2
ID	sd0	60	3	0x55aa57d34658
LESS	<	60	6
ID	sd1	60	7	0x55aa57d34680
RPAREN	)	60	10
LBRACE	{	60	11
ID	ret	61	0	0x55aa57d34630
LBRACKET	[	61	3
DECIMAL	0	61	4	0
RBRACKET	]	61	5
ASSIGN	=	61	6
ID	sd0	61	7	0x55aa57d34658
SEMICOLON	;	61	10
ID	ret	62	0	0x55aa57d34630
LBRACKET	[	62	3
DECIMAL	1	62	4	1
RBRACKET	]	62	5
ASSIGN	=	62	6
FLOAT	3.0	62	7	3.000000
SEMICOLON	;	62	10
RBRACE	}	63	0
ELSE	else	63	1
LBRACE	{	63	5
ID	ret	64	0	0x55aa57d34630
LBRACKET	[	64	3
DECIMAL	0	64	4	0
RBRACKET	]	64	5
ASSIGN	=	64	6
ID	sd1	64	7	0x55aa57d34680
SEMICOLON	;	64	10
ID	ret	65	0	0x55aa57d34630
LBRACKET	[	65	3
DECIMAL	1	65	4	1
RBRACKET	]	65	5
ASSIGN	=	65	6
FLOAT	0.0	65	7	0.000000
SEMICOLON	;	65	10
RBRACE	}	66	0
RBRACE	}	67	0
FLOAT	float	69	0
ID	trace	69	5	0x55aa57d346a8
LPAREN	(	69	10
FLOAT	float	69	11
ID	ox	69	16	0x55aa57d346d0
COMMA	,	69	18
FLOAT	float	69	19
ID	oy	69	24	0x55aa57d346f8
COMMA	,	69	26
FLOAT	float	69	27
ID	dx	69	32	0x55aa57d34720
COMMA	,	69	34
FLOAT	float	69	35
ID	dy	69	40	0x55aa57d34748
RPAREN	)	69	42
LBRACE	{	69	43
FLOAT	float	70	0
ID	t	70	5	0x55aa57d343d8
ASSIGN	=	70	6
FLOAT	0.0	70	7	0.000000
SEMICOLON	;	70	10
INT	int	71	0
ID	i	71	3	0x55aa57d34770
ASSIGN	=	71	4
DECIMAL	0	71	5	0
SEMICOLON	;	71	6
WHILE	while	72	0
LPAREN	(	72	5
ID	i	72	6	0x55aa57d34770
LESS	<	72	7
ID	MAX_STEP	72	8	0x55aa57d34270
AND	&&	72	16
ID	t	72	18	0x55aa57d343d8
LESS	<	72	19
ID	MAX_DISTANCE	72	20	0x55aa57d34298
RPAREN	)	72	32
LBRACE	{	72	33
FLOAT	float	73	0
ID	ret	73	5	0x55aa57d34630
LBRACKET	[	73	8
DECIMAL	2	73	9	2
RBRACKET	]	73	10
SEMICOLON	;	73	11
ID	scene	74	0	0x55aa57d34608
LPAREN	(	74	5
ID	ox	74	6	0x55aa57d346d0
ADD	+	74	8
ID	dx	74	9	0x55aa57d34720
MUL	*	74	11
ID	t	74	12	0x55aa57d343d8
COMMA	,	74	13
ID	oy	74	14	0x55aa57d346f8
ADD	+	74	16
ID	dy	74	17	0x55aa57d34748
MUL	*	74	19
ID	t	74	20	0x55aa57d343d8
COMMA	,	74	21
ID	ret	74	22	0x55aa57d34630
RPAREN	)	74	25
SEMICOLON	;	74	26
IF	if	75	0
LPAREN	(	75	2
ID	ret	75	3	0x55aa57d34630
LBRACKET	[	75	6
DECIMAL	0	75	7	0
RBRACKET	]	75	8
LESS	<	75	9
ID	EPSILON	75	10	0x55aa57d342c0
RPAREN	)	75	17
RETURN	return	75	18
ID	ret	75	24	0x55aa57d34630
LBRACKET	[	75	27
DECIMAL	1	75	28	1
RBRACKET	]	75	29
SEMICOLON	;	75	30
ID	t	76	0	0x55aa57d343d8
ASSIGN	=	76	1
ID	t	76	2	0x55aa57d343d8
ADD	+	76	3
ID	ret	76	4	0x55aa57d34630
LBRACKET	[	76	7
DECIMAL	0	76	8	0
RBRACKET	]	76	9
SEMICOLON	;	76	10
ID	i	77	0	0x55aa57d34770
ASSIGN	=	77	1
ID	i	77	2	0x55aa57d34770
ADD	+	77	3
DECIMAL	1	77	4	1
SEMICOLON	;	77	5
RBRACE	}	78	0
RETURN	return	79	0
FLOAT	0.0	79	6	0.000000
SEMICOLON	;	79	9
RBRACE	}	80	0
FLOAT	float	82	0
ID	sample	82	5	0x55aa57d34798
LPAREN	(	82	11
FLOAT	float	82	12
ID	x	82	17	0x55aa57d34388
COMMA	,	82	18
FLOAT	float	82	19
ID	y	82	24	0x55aa57d34518
RPAREN	)	82	25
LBRACE	{	82	26
FLOAT	float	83	0
ID	sum	83	5	0x55aa57d347c0
ASSIGN	=	83	8
FLOAT	0.0	83	9	0.000000
SEMICOLON	;	83	12
INT	int	84	0
ID	i	84	3	0x55aa57d34770
ASSIGN	=	84	4
DECIMAL	0	84	5	0
SEMICOLON	;	84	6
WHILE	while	85	0
LPAREN	(	85	5
ID	i	85	6	0x55aa57d34770
LESS	<	85	7
ID	N	85	8	0x55aa57d341f8
RPAREN	)	85	9
LBRACE	{	85	10
FLOAT	float	86	0
ID	rnd	86	5	0x55aa57d347e8
ASSIGN	=	86	8
ID	rand	86	9	0x55aa57d34338
LPAREN	(	86	13
RPAREN	)	86	14
SEMICOLON	;	86	15
FLOAT	float	87	0
ID	a	87	5	0x55aa57d34810
ASSIGN	=	87	6
ID	TWO_PI	87	7	0x55aa57d34248
MUL	*	87	13
LPAREN	(	87	14
ID	i	87	15	0x55aa57d34770
ADD	+	87	16
ID	rnd	87	17	0x55aa57d347e8
DIV	/	87	20
ID	RAND_MAX	87	21	0x55aa57d342e8
RPAREN	)	87	29
DIV	/	87	30
ID	N	87	31	0x55aa57d341f8
SEMICOLON	;	87	32
ID	sum	88	0	0x55aa57d347c0
ASSIGN	=	88	3
ID	sum	88	4	0x55aa57d347c0
ADD	+	88	7
ID	trace	88	8	0x55aa57d346a8
LPAREN	(	88	13
ID	x	88	14	0x55aa57d34388
COMMA	,	88	15
ID	y	88	16	0x55aa57d34518
COMMA	,	88	17
ID	my_cos	88	18	0x55aa57d344c8
LPAREN	(	88	24
ID	a	88	25	0x55aa57d34810
RPAREN	)	88	26
COMMA	,	88	27
ID	my_sin	88	28	0x55aa57d34478
LPAREN	(	88	34
ID	a	88	35	0x55aa57d34810
RPAREN	)	88	36
RPAREN	)	88	37
SEMICOLON	;	88	38
ID	i	89	0	0x55aa57d34770
ASSIGN	=	89	1
ID	i	89	2	0x55aa57d34770
ADD	+	89	3
DECIMAL	1	89	4	1
SEMICOLON	;	89	5
RBRACE	}	90	0
RETURN	return	91	0
ID	sum	91	6	0x55aa57d347c0
DIV	/	91	9
ID	N	91	10	0x55aa57d341f8
SEMICOLON	;	91	11
RBRACE	}	92	0
VOID	void	94	0
ID	write_pgm	94	4	0x55aa57d34838
LPAREN	(	94	13
RPAREN	)	94	14
LBRACE	{	94	15
ID	putch	95	0	0x55aa57d34860
LPAREN	(	95	5
DECIMAL	80	95	6	80
RPAREN	)	95	8
SEMICOLON	;	95	9
ID	putch	95	10	0x55aa57d34860
LPAREN	(	95	15
DECIMAL	50	95	16	50
RPAREN	)	95	18
SEMICOLON	;	95	19
ID	putch	95	20	0x55aa57d34860
LPAREN	(	95	25
DECIMAL	10	95	26	10
RPAREN	)	95	28
SEMICOLON	;	95	29
ID	putint	96	0	0x55aa57d34888
LPAREN	(	96	6
ID	W	96	7	0x55aa57d341a8
RPAREN	)	96	8
SEMICOLON	;	96	9
ID	putch	96	10	0x55aa57d34860
LPAREN	(	96	15
DECIMAL	32	96	16	32
RPAREN	)	96	18
SEMICOLON	;	96	19
ID	putint	96	20	0x55aa57d34888
LPAREN	(	96	26
ID	H	96	27	0x55aa57d341d0
RPAREN	)	96	28
SEMICOLON	;	96	29
ID	putch	96	30	0x55aa57d34860
LPAREN	(	96	35
DECIMAL	32	96	36	32
RPAREN	)	96	38
SEMICOLON	;	96	39
ID	putint	96	40	0x55aa57d34888
LPAREN	(	96	46
DECIMAL	255	96	47	255
RPAREN	)	96	50
SEMICOLON	;	96	51
ID	putch	96	52	0x55aa57d34860
LPAREN	(	96	57
DECIMAL	10	96	58	10
RPAREN	)	96	60
SEMICOLON	;	96	61
INT	int	97	0
ID	y	97	3	0x55aa57d34518
ASSIGN	=	97	4
DECIMAL	0	97	5	0
SEMICOLON	;	97	6
WHILE	while	98	0
LPAREN	(	98	5
ID	y	98	6	0x55aa57d34518
LESS	<	98	7
ID	H	98	8	0x55aa57d341d0
RPAREN	)	98	9
LBRACE	{	98	10
INT	int	99	0
ID	x	99	3	0x55aa57d34388
ASSIGN	=	99	4
DECIMAL	0	99	5	0
SEMICOLON	;	99	6
WHILE	while	100	0
LPAREN	(	100	5
ID	x	100	6	0x55aa57d34388
LESS	<	100	7
ID	W	100	8	0x55aa57d341a8
RPAREN	)	100	9
LBRACE	{	100	10
FLOAT	float	101	0
ID	xx	101	5	0x55aa57d344a0
ASSIGN	=	101	7
ID	x	101	8	0x55aa57d34388
COMMA	,	101	9
ID	yy	101	10	0x55aa57d348b0
ASSIGN	=	101	12
ID	y	101	13	0x55aa57d34518
SEMICOLON	;	101	14
INT	int	102	0
ID	p	102	3	0x55aa57d34428
ASSIGN	=	102	4
ID	sample	102	5	0x55aa57d34798
LPAREN	(	102	11
ID	xx	102	12	0x55aa57d344a0
DIV	/	102	14
ID	W	102	15	0x55aa57d341a8
COMMA	,	102	16
ID	yy	102	17	0x55aa57d348b0
DIV	/	102	19
ID	H	102	20	0x55aa57d341d0
RPAREN	)	102	21
MUL	*	102	22
FLOAT	255.0	102	23	255.000000
SEMICOLON	;	102	28
IF	if	103	0
LPAREN	(	103	2
ID	p	103	3	0x55aa57d34428
GREATER	>	103	4
DECIMAL	255	103	5	255
RPAREN	)	103	8
ID	p	103	9	0x55aa57d34428
ASSIGN	=	103	10
DECIMAL	255	103	11	255
SEMICOLON	;	103	14
ID	putint	104	0	0x55aa57d34888
LPAREN	(	104	6
ID	p	104	7	0x55aa57d34428
RPAREN	)	104	8
SEMICOLON	;	104	9
ID	putch	105	0	0x55aa57d34860
LPAREN	(	105	5
DECIMAL	32	105	6	32
RPAREN	)	105	8
SEMICOLON	;	105	9
ID	x	106	0	0x55aa57d34388
ASSIGN	=	106	1
ID	x	106	2	0x55aa57d34388
ADD	+	106	3
DECIMAL	1	106	4	1
SEMICOLON	;	106	5
RBRACE	}	107	0
ID	putch	108	0	0x55aa57d34860
LPAREN	(	108	5
DECIMAL	10	108	6	10
RPAREN	)	108	8
SEMICOLON	;	108	9
ID	y	109	0	0x55aa57d34518
ASSIGN	=	109	1
ID	y	109	2	0x55aa57d34518
ADD	+	109	3
DECIMAL	1	109	4	1
SEMICOLON	;	109	5
RBRACE	}	110	0
RBRACE	}	111	0
INT	int	113	0
ID	main	113	3	0x55aa57d348d8
LPAREN	(	113	7
RPAREN	)	113	8
LBRACE	{	113	9
ID	write_pgm	114	0	0x55aa57d34838
LPAREN	(	114	9
RPAREN	)	114	10
SEMICOLON	;	114	11
RETURN	return	115	0
DECIMAL	0	115	6	0
SEMICOLON	;	115	7
RBRACE	}	116	0
