INT	int	0	0
ID	n	0	3	0x564ed622e1a8
SEMICOLON	;	0	4
INT	int	1	0
ID	swap	1	3	0x564ed622e1d0
LPAREN	(	1	7
INT	int	1	8
ID	array	1	11	0x564ed622e1f8
LBRACKET	[	1	16
RBRACKET	]	1	17
COMMA	,	1	18
INT	int	1	19
ID	i	1	22	0x564ed622e220
COMMA	,	1	23
INT	int	1	24
ID	j	1	27	0x564ed622e248
RPAREN	)	1	28
LBRACE	{	1	29
INT	int	2	0
ID	temp	2	3	0x564ed622e270
SEMICOLON	;	2	7
ID	temp	3	0	0x564ed622e270
ASSIGN	=	3	4
ID	array	3	5	0x564ed622e1f8
LBRACKET	[	3	10
ID	i	3	11	0x564ed622e220
RBRACKET	]	3	12
SEMICOLON	;	3	13
ID	array	4	0	0x564ed622e1f8
LBRACKET	[	4	5
ID	i	4	6	0x564ed622e220
RBRACKET	]	4	7
ASSIGN	=	4	8
ID	array	4	9	0x564ed622e1f8
LBRACKET	[	4	14
ID	j	4	15	0x564ed622e248
RBRACKET	]	4	16
SEMICOLON	;	4	17
ID	array	5	0	0x564ed622e1f8
LBRACKET	[	5	5
ID	j	5	6	0x564ed622e248
RBRACKET	]	5	7
ASSIGN	=	5	8
ID	temp	5	9	0x564ed622e270
SEMICOLON	;	5	13
RETURN	return	6	0
DECIMAL	0	6	6	0
SEMICOLON	;	6	7
RBRACE	}	7	0
INT	int	8	0
ID	heap_ajust	8	3	0x564ed622e298
LPAREN	(	8	13
INT	int	8	14
ID	arr	8	17	0x564ed622e2c0
LBRACKET	[	8	20
RBRACKET	]	8	21
COMMA	,	8	22
INT	int	8	23
ID	start	8	26	0x564ed622e2e8
COMMA	,	8	31
INT	int	8	32
ID	end	8	35	0x564ed622e310
RPAREN	)	8	38
LBRACE	{	8	39
INT	int	9	0
ID	dad	9	3	0x564ed622e338
SEMICOLON	;	9	6
ID	dad	10	0	0x564ed622e338
ASSIGN	=	10	3
ID	start	10	4	0x564ed622e2e8
SEMICOLON	;	10	9
INT	int	11	0
ID	son	11	3	0x564ed622e360
SEMICOLON	;	11	6
ID	son	12	0	0x564ed622e360
ASSIGN	=	12	3
ID	dad	12	4	0x564ed622e338
MUL	*	12	7
DECIMAL	2	12	8	2
ADD	+	12	9
DECIMAL	1	12	10	1
SEMICOLON	;	12	11
WHILE	while	13	0
LPAREN	(	13	5
ID	son	13	6	0x564ed622e360
LESS	<	13	9
ID	end	13	10	0x564ed622e310
ADD	+	13	13
DECIMAL	1	13	14	1
RPAREN	)	13	15
LBRACE	{	13	16
IF	if	14	0
LPAREN	(	14	2
ID	son	14	3	0x564ed622e360
LESS	<	14	6
ID	end	14	7	0x564ed622e310
AND	&&	14	10
ID	arr	14	12	0x564ed622e2c0
LBRACKET	[	14	15
ID	son	14	16	0x564ed622e360
RBRACKET	]	14	19
LESS	<	14	20
ID	arr	14	21	0x564ed622e2c0
LBRACKET	[	14	24
ID	son	14	25	0x564ed622e360
ADD	+	14	28
DECIMAL	1	14	29	1
RBRACKET	]	14	30
RPAREN	)	14	31
ID	son	15	0	0x564ed622e360
ASSIGN	=	15	3
ID	son	15	4	0x564ed622e360
ADD	+	15	7
DECIMAL	1	15	8	1
SEMICOLON	;	15	9
IF	if	16	0
LPAREN	(	16	2
ID	arr	16	3	0x564ed622e2c0
LBRACKET	[	16	6
ID	dad	16	7	0x564ed622e338
RBRACKET	]	16	10
GREATER	>	16	11
ID	arr	16	12	0x564ed622e2c0
LBRACKET	[	16	15
ID	son	16	16	0x564ed622e360
RBRACKET	]	16	19
RPAREN	)	16	20
RETURN	return	17	0
DECIMAL	0	17	6	0
SEMICOLON	;	17	7
ELSE	else	18	0
LBRACE	{	18	4
ID	dad	19	0	0x564ed622e338
ASSIGN	=	19	3
ID	swap	19	4	0x564ed622e1d0
LPAREN	(	19	8
ID	arr	19	9	0x564ed622e2c0
COMMA	,	19	12
ID	dad	19	13	0x564ed622e338
COMMA	,	19	16
ID	son	19	17	0x564ed622e360
RPAREN	)	19	20
SEMICOLON	;	19	21
ID	dad	20	0	0x564ed622e338
ASSIGN	=	20	3
ID	son	20	4	0x564ed622e360
SEMICOLON	;	20	7
ID	son	21	0	0x564ed622e360
ASSIGN	=	21	3
ID	dad	21	4	0x564ed622e338
MUL	*	21	7
DECIMAL	2	21	8	2
ADD	+	21	9
DECIMAL	1	21	10	1
SEMICOLON	;	21	11
RBRACE	}	22	0
RBRACE	}	23	0
RETURN	return	24	0
DECIMAL	0	24	6	0
SEMICOLON	;	24	7
RBRACE	}	25	0
INT	int	26	0
ID	heap_sort	26	3	0x564ed622e388
LPAREN	(	26	12
INT	int	26	13
ID	arr	26	16	0x564ed622e2c0
LBRACKET	[	26	19
RBRACKET	]	26	20
COMMA	,	26	21
INT	int	26	22
ID	len	26	25	0x564ed622e3b0
RPAREN	)	26	28
LBRACE	{	26	29
INT	int	27	0
ID	i	27	3	0x564ed622e220
SEMICOLON	;	27	4
INT	int	28	0
ID	tmp	28	3	0x564ed622e3d8
SEMICOLON	;	28	6
ID	i	29	0	0x564ed622e220
ASSIGN	=	29	1
ID	len	29	2	0x564ed622e3b0
DIV	/	29	5
DECIMAL	2	29	6	2
SUB	-	29	7
DECIMAL	1	29	8	1
SEMICOLON	;	29	9
WHILE	while	30	0
LPAREN	(	30	5
ID	i	30	6	0x564ed622e220
GREATER	>	30	7
SUB	-	30	8
DECIMAL	1	30	9	1
RPAREN	)	30	10
LBRACE	{	30	11
ID	tmp	31	0	0x564ed622e3d8
ASSIGN	=	31	3
ID	len	31	4	0x564ed622e3b0
SUB	-	31	7
DECIMAL	1	31	8	1
SEMICOLON	;	31	9
ID	tmp	32	0	0x564ed622e3d8
ASSIGN	=	32	3
ID	heap_ajust	32	4	0x564ed622e298
LPAREN	(	32	14
ID	arr	32	15	0x564ed622e2c0
COMMA	,	32	18
ID	i	32	19	0x564ed622e220
COMMA	,	32	20
ID	tmp	32	21	0x564ed622e3d8
RPAREN	)	32	24
SEMICOLON	;	32	25
ID	i	33	0	0x564ed622e220
ASSIGN	=	33	1
ID	i	33	2	0x564ed622e220
SUB	-	33	3
DECIMAL	1	33	4	1
SEMICOLON	;	33	5
RBRACE	}	34	0
ID	i	35	0	0x564ed622e220
ASSIGN	=	35	1
ID	len	35	2	0x564ed622e3b0
SUB	-	35	5
DECIMAL	1	35	6	1
SEMICOLON	;	35	7
WHILE	while	36	0
LPAREN	(	36	5
ID	i	36	6	0x564ed622e220
GREATER	>	36	7
DECIMAL	0	36	8	0
RPAREN	)	36	9
LBRACE	{	36	10
INT	int	37	0
ID	tmp0	37	3	0x564ed622e400
SEMICOLON	;	37	7
ID	tmp0	38	0	0x564ed622e400
ASSIGN	=	38	4
DECIMAL	0	38	5	0
SEMICOLON	;	38	6
ID	tmp	39	0	0x564ed622e3d8
ASSIGN	=	39	3
ID	swap	39	4	0x564ed622e1d0
LPAREN	(	39	8
ID	arr	39	9	0x564ed622e2c0
COMMA	,	39	12
ID	tmp0	39	13	0x564ed622e400
COMMA	,	39	17
ID	i	39	18	0x564ed622e220
RPAREN	)	39	19
SEMICOLON	;	39	20
ID	tmp	40	0	0x564ed622e3d8
ASSIGN	=	40	3
ID	i	40	4	0x564ed622e220
SUB	-	40	5
DECIMAL	1	40	6	1
SEMICOLON	;	40	7
ID	tmp	41	0	0x564ed622e3d8
ASSIGN	=	41	3
ID	heap_ajust	41	4	0x564ed622e298
LPAREN	(	41	14
ID	arr	41	15	0x564ed622e2c0
COMMA	,	41	18
ID	tmp0	41	19	0x564ed622e400
COMMA	,	41	23
ID	tmp	41	24	0x564ed622e3d8
RPAREN	)	41	27
SEMICOLON	;	41	28
ID	i	42	0	0x564ed622e220
ASSIGN	=	42	1
ID	i	42	2	0x564ed622e220
SUB	-	42	3
DECIMAL	1	42	4	1
SEMICOLON	;	42	5
RBRACE	}	43	0
RETURN	return	44	0
DECIMAL	0	44	6	0
SEMICOLON	;	44	7
RBRACE	}	45	0
INT	int	47	0
ID	main	47	3	0x564ed622e428
LPAREN	(	47	7
RPAREN	)	47	8
LBRACE	{	47	9
ID	n	48	0	0x564ed622e1a8
ASSIGN	=	48	1
DECIMAL	10	48	2	10
SEMICOLON	;	48	4
INT	int	49	0
ID	a	49	3	0x564ed622e450
LBRACKET	[	49	4
DECIMAL	10	49	5	10
RBRACKET	]	49	7
SEMICOLON	;	49	8
ID	a	50	0	0x564ed622e450
LBRACKET	[	50	1
DECIMAL	0	50	2	0
RBRACKET	]	50	3
ASSIGN	=	50	4
DECIMAL	4	50	5	4
SEMICOLON	;	50	6
ID	a	50	7	0x564ed622e450
LBRACKET	[	50	8
DECIMAL	1	50	9	1
RBRACKET	]	50	10
ASSIGN	=	50	11
DECIMAL	3	50	12	3
SEMICOLON	;	50	13
ID	a	50	14	0x564ed622e450
LBRACKET	[	50	15
DECIMAL	2	50	16	2
RBRACKET	]	50	17
ASSIGN	=	50	18
DECIMAL	9	50	19	9
SEMICOLON	;	50	20
ID	a	50	21	0x564ed622e450
LBRACKET	[	50	22
DECIMAL	3	50	23	3
RBRACKET	]	50	24
ASSIGN	=	50	25
DECIMAL	2	50	26	2
SEMICOLON	;	50	27
ID	a	50	28	0x564ed622e450
LBRACKET	[	50	29
DECIMAL	4	50	30	4
RBRACKET	]	50	31
ASSIGN	=	50	32
DECIMAL	0	50	33	0
SEMICOLON	;	50	34
ID	a	51	0	0x564ed622e450
LBRACKET	[	51	1
DECIMAL	5	51	2	5
RBRACKET	]	51	3
ASSIGN	=	51	4
DECIMAL	1	51	5	1
SEMICOLON	;	51	6
ID	a	51	7	0x564ed622e450
LBRACKET	[	51	8
DECIMAL	6	51	9	6
RBRACKET	]	51	10
ASSIGN	=	51	11
DECIMAL	6	51	12	6
SEMICOLON	;	51	13
ID	a	51	14	0x564ed622e450
LBRACKET	[	51	15
DECIMAL	7	51	16	7
RBRACKET	]	51	17
ASSIGN	=	51	18
DECIMAL	5	51	19	5
SEMICOLON	;	51	20
ID	a	51	21	0x564ed622e450
LBRACKET	[	51	22
DECIMAL	8	51	23	8
RBRACKET	]	51	24
ASSIGN	=	51	25
DECIMAL	7	51	26	7
SEMICOLON	;	51	27
ID	a	51	28	0x564ed622e450
LBRACKET	[	51	29
DECIMAL	9	51	30	9
RBRACKET	]	51	31
ASSIGN	=	51	32
DECIMAL	8	51	33	8
SEMICOLON	;	51	34
INT	int	52	0
ID	i	52	3	0x564ed622e220
SEMICOLON	;	52	4
ID	i	53	0	0x564ed622e220
ASSIGN	=	53	1
DECIMAL	0	53	2	0
SEMICOLON	;	53	3
ID	i	54	0	0x564ed622e220
ASSIGN	=	54	1
ID	heap_sort	54	2	0x564ed622e388
LPAREN	(	54	11
ID	a	54	12	0x564ed622e450
COMMA	,	54	13
ID	n	54	14	0x564ed622e1a8
RPAREN	)	54	15
SEMICOLON	;	54	16
WHILE	while	55	0
LPAREN	(	55	5
ID	i	55	6	0x564ed622e220
LESS	<	55	7
ID	n	55	8	0x564ed622e1a8
RPAREN	)	55	9
LBRACE	{	55	10
INT	int	56	0
ID	tmp	56	3	0x564ed622e3d8
SEMICOLON	;	56	6
ID	tmp	57	0	0x564ed622e3d8
ASSIGN	=	57	3
ID	a	57	4	0x564ed622e450
LBRACKET	[	57	5
ID	i	57	6	0x564ed622e220
RBRACKET	]	57	7
SEMICOLON	;	57	8
ID	putint	58	0	0x564ed622e478
LPAREN	(	58	6
ID	tmp	58	7	0x564ed622e3d8
RPAREN	)	58	10
SEMICOLON	;	58	11
ID	tmp	59	0	0x564ed622e3d8
ASSIGN	=	59	3
DECIMAL	10	59	4	10
SEMICOLON	;	59	6
ID	putch	60	0	0x564ed622e4a0
LPAREN	(	60	5
ID	tmp	60	6	0x564ed622e3d8
RPAREN	)	60	9
SEMICOLON	;	60	10
ID	i	61	0	0x564ed622e220
ASSIGN	=	61	1
ID	i	61	2	0x564ed622e220
ADD	+	61	3
DECIMAL	1	61	4	1
SEMICOLON	;	61	5
RBRACE	}	62	0
RETURN	return	63	0
DECIMAL	0	63	6	0
SEMICOLON	;	63	7
RBRACE	}	64	0
