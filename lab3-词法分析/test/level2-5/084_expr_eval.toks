CONST	const	0	0
INT	int	0	5
ID	TOKEN_NUM	0	8	0x556ce6fac1a8
ASSIGN	=	0	17
DECIMAL	0	0	18	0
COMMA	,	0	19
ID	TOKEN_OTHER	0	20	0x556ce6fac1d0
ASSIGN	=	0	31
DECIMAL	1	0	32	1
SEMICOLON	;	0	33
INT	int	1	0
ID	last_char	1	3	0x556ce6fac1f8
ASSIGN	=	1	12
DECIMAL	32	1	13	32
COMMA	,	1	15
ID	num	1	16	0x556ce6fac220
COMMA	,	1	19
ID	other	1	20	0x556ce6fac248
SEMICOLON	;	1	25
INT	int	2	0
ID	cur_token	2	3	0x556ce6fac270
SEMICOLON	;	2	12
INT	int	4	0
ID	next_char	4	3	0x556ce6fac298
LPAREN	(	4	12
RPAREN	)	4	13
LBRACE	{	4	14
ID	last_char	5	0	0x556ce6fac1f8
ASSIGN	=	5	9
ID	getch	5	10	0x556ce6fac2c0
LPAREN	(	5	15
RPAREN	)	5	16
SEMICOLON	;	5	17
RETURN	return	6	0
ID	last_char	6	6	0x556ce6fac1f8
SEMICOLON	;	6	15
RBRACE	}	7	0
INT	int	9	0
ID	is_space	9	3	0x556ce6fac2e8
LPAREN	(	9	11
INT	int	9	12
ID	c	9	15	0x556ce6fac310
RPAREN	)	9	16
LBRACE	{	9	17
IF	if	10	0
LPAREN	(	10	2
ID	c	10	3	0x556ce6fac310
EQUAL	==	10	4
DECIMAL	32	10	6	32
OR	||	10	8
ID	c	10	10	0x556ce6fac310
EQUAL	==	10	11
DECIMAL	10	10	13	10
RPAREN	)	10	15
LBRACE	{	10	16
RETURN	return	11	0
DECIMAL	1	11	6	1
SEMICOLON	;	11	7
RBRACE	}	12	0
ELSE	else	13	0
LBRACE	{	13	4
RETURN	return	14	0
DECIMAL	0	14	6	0
SEMICOLON	;	14	7
RBRACE	}	15	0
RBRACE	}	16	0
INT	int	18	0
ID	is_num	18	3	0x556ce6fac338
LPAREN	(	18	9
INT	int	18	10
ID	c	18	13	0x556ce6fac310
RPAREN	)	18	14
LBRACE	{	18	15
IF	if	19	0
LPAREN	(	19	2
ID	c	19	3	0x556ce6fac310
GEQUAL	>=	19	4
DECIMAL	48	19	6	48
AND	&&	19	8
ID	c	19	10	0x556ce6fac310
LEQUAL	<=	19	11
DECIMAL	57	19	13	57
RPAREN	)	19	15
LBRACE	{	19	16
RETURN	return	20	0
DECIMAL	1	20	6	1
SEMICOLON	;	20	7
RBRACE	}	21	0
ELSE	else	22	0
LBRACE	{	22	4
RETURN	return	23	0
DECIMAL	0	23	6	0
SEMICOLON	;	23	7
RBRACE	}	24	0
RBRACE	}	25	0
INT	int	27	0
ID	next_token	27	3	0x556ce6fac360
LPAREN	(	27	13
RPAREN	)	27	14
LBRACE	{	27	15
WHILE	while	28	0
LPAREN	(	28	5
ID	is_space	28	6	0x556ce6fac2e8
LPAREN	(	28	14
ID	last_char	28	15	0x556ce6fac1f8
RPAREN	)	28	24
RPAREN	)	28	25
ID	next_char	28	26	0x556ce6fac298
LPAREN	(	28	35
RPAREN	)	28	36
SEMICOLON	;	28	37
IF	if	29	0
LPAREN	(	29	2
ID	is_num	29	3	0x556ce6fac338
LPAREN	(	29	9
ID	last_char	29	10	0x556ce6fac1f8
RPAREN	)	29	19
RPAREN	)	29	20
LBRACE	{	29	21
ID	num	30	0	0x556ce6fac220
ASSIGN	=	30	3
ID	last_char	30	4	0x556ce6fac1f8
SUB	-	30	13
DECIMAL	48	30	14	48
SEMICOLON	;	30	16
WHILE	while	31	0
LPAREN	(	31	5
ID	is_num	31	6	0x556ce6fac338
LPAREN	(	31	12
ID	next_char	31	13	0x556ce6fac298
LPAREN	(	31	22
RPAREN	)	31	23
RPAREN	)	31	24
RPAREN	)	31	25
LBRACE	{	31	26
ID	num	32	0	0x556ce6fac220
ASSIGN	=	32	3
ID	num	32	4	0x556ce6fac220
MUL	*	32	7
DECIMAL	10	32	8	10
ADD	+	32	10
ID	last_char	32	11	0x556ce6fac1f8
SUB	-	32	20
DECIMAL	48	32	21	48
SEMICOLON	;	32	23
RBRACE	}	33	0
ID	cur_token	34	0	0x556ce6fac270
ASSIGN	=	34	9
ID	TOKEN_NUM	34	10	0x556ce6fac1a8
SEMICOLON	;	34	19
RBRACE	}	35	0
ELSE	else	36	0
LBRACE	{	36	4
ID	other	37	0	0x556ce6fac248
ASSIGN	=	37	5
ID	last_char	37	6	0x556ce6fac1f8
SEMICOLON	;	37	15
ID	next_char	38	0	0x556ce6fac298
LPAREN	(	38	9
RPAREN	)	38	10
SEMICOLON	;	38	11
ID	cur_token	39	0	0x556ce6fac270
ASSIGN	=	39	9
ID	TOKEN_OTHER	39	10	0x556ce6fac1d0
SEMICOLON	;	39	21
RBRACE	}	40	0
RETURN	return	41	0
ID	cur_token	41	6	0x556ce6fac270
SEMICOLON	;	41	15
RBRACE	}	42	0
INT	int	44	0
ID	panic	44	3	0x556ce6fac388
LPAREN	(	44	8
RPAREN	)	44	9
LBRACE	{	44	10
ID	putch	45	0	0x556ce6fac3b0
LPAREN	(	45	5
DECIMAL	112	45	6	112
RPAREN	)	45	9
SEMICOLON	;	45	10
ID	putch	46	0	0x556ce6fac3b0
LPAREN	(	46	5
DECIMAL	97	46	6	97
RPAREN	)	46	8
SEMICOLON	;	46	9
ID	putch	47	0	0x556ce6fac3b0
LPAREN	(	47	5
DECIMAL	110	47	6	110
RPAREN	)	47	9
SEMICOLON	;	47	10
ID	putch	48	0	0x556ce6fac3b0
LPAREN	(	48	5
DECIMAL	105	48	6	105
RPAREN	)	48	9
SEMICOLON	;	48	10
ID	putch	49	0	0x556ce6fac3b0
LPAREN	(	49	5
DECIMAL	99	49	6	99
RPAREN	)	49	8
SEMICOLON	;	49	9
ID	putch	50	0	0x556ce6fac3b0
LPAREN	(	50	5
DECIMAL	33	50	6	33
RPAREN	)	50	8
SEMICOLON	;	50	9
ID	putch	51	0	0x556ce6fac3b0
LPAREN	(	51	5
DECIMAL	10	51	6	10
RPAREN	)	51	8
SEMICOLON	;	51	9
RETURN	return	52	0
SUB	-	52	6
DECIMAL	1	52	7	1
SEMICOLON	;	52	8
RBRACE	}	53	0
INT	int	55	0
ID	get_op_prec	55	3	0x556ce6fac3d8
LPAREN	(	55	14
INT	int	55	15
ID	op	55	18	0x556ce6fac400
RPAREN	)	55	20
LBRACE	{	55	21
IF	if	57	0
LPAREN	(	57	2
ID	op	57	3	0x556ce6fac400
EQUAL	==	57	5
DECIMAL	43	57	7	43
OR	||	57	9
ID	op	57	11	0x556ce6fac400
EQUAL	==	57	13
DECIMAL	45	57	15	45
RPAREN	)	57	17
RETURN	return	57	18
DECIMAL	10	57	24	10
SEMICOLON	;	57	26
IF	if	59	0
LPAREN	(	59	2
ID	op	59	3	0x556ce6fac400
EQUAL	==	59	5
DECIMAL	42	59	7	42
OR	||	59	9
ID	op	59	11	0x556ce6fac400
EQUAL	==	59	13
DECIMAL	47	59	15	47
OR	||	59	17
ID	op	59	19	0x556ce6fac400
EQUAL	==	59	21
DECIMAL	37	59	23	37
RPAREN	)	59	25
RETURN	return	59	26
DECIMAL	20	59	32	20
SEMICOLON	;	59	34
RETURN	return	61	0
DECIMAL	0	61	6	0
SEMICOLON	;	61	7
RBRACE	}	62	0
VOID	void	64	0
ID	stack_push	64	4	0x556ce6fac428
LPAREN	(	64	14
INT	int	64	15
ID	s	64	18	0x556ce6fac450
LBRACKET	[	64	19
RBRACKET	]	64	20
COMMA	,	64	21
INT	int	64	22
ID	v	64	25	0x556ce6fac478
RPAREN	)	64	26
LBRACE	{	64	27
ID	s	65	0	0x556ce6fac450
LBRACKET	[	65	1
DECIMAL	0	65	2	0
RBRACKET	]	65	3
ASSIGN	=	65	4
ID	s	65	5	0x556ce6fac450
LBRACKET	[	65	6
DECIMAL	0	65	7	0
RBRACKET	]	65	8
ADD	+	65	9
DECIMAL	1	65	10	1
SEMICOLON	;	65	11
ID	s	66	0	0x556ce6fac450
LBRACKET	[	66	1
ID	s	66	2	0x556ce6fac450
LBRACKET	[	66	3
DECIMAL	0	66	4	0
RBRACKET	]	66	5
RBRACKET	]	66	6
ASSIGN	=	66	7
ID	v	66	8	0x556ce6fac478
SEMICOLON	;	66	9
RBRACE	}	67	0
INT	int	69	0
ID	stack_pop	69	3	0x556ce6fac4a0
LPAREN	(	69	12
INT	int	69	13
ID	s	69	16	0x556ce6fac450
LBRACKET	[	69	17
RBRACKET	]	69	18
RPAREN	)	69	19
LBRACE	{	69	20
INT	int	70	0
ID	last	70	3	0x556ce6fac4c8
ASSIGN	=	70	7
ID	s	70	8	0x556ce6fac450
LBRACKET	[	70	9
ID	s	70	10	0x556ce6fac450
LBRACKET	[	70	11
DECIMAL	0	70	12	0
RBRACKET	]	70	13
RBRACKET	]	70	14
SEMICOLON	;	70	15
ID	s	71	0	0x556ce6fac450
LBRACKET	[	71	1
DECIMAL	0	71	2	0
RBRACKET	]	71	3
ASSIGN	=	71	4
ID	s	71	5	0x556ce6fac450
LBRACKET	[	71	6
DECIMAL	0	71	7	0
RBRACKET	]	71	8
SUB	-	71	9
DECIMAL	1	71	10	1
SEMICOLON	;	71	11
RETURN	return	72	0
ID	last	72	6	0x556ce6fac4c8
SEMICOLON	;	72	10
RBRACE	}	73	0
INT	int	75	0
ID	stack_peek	75	3	0x556ce6fac4f0
LPAREN	(	75	13
INT	int	75	14
ID	s	75	17	0x556ce6fac450
LBRACKET	[	75	18
RBRACKET	]	75	19
RPAREN	)	75	20
LBRACE	{	75	21
RETURN	return	76	0
ID	s	76	6	0x556ce6fac450
LBRACKET	[	76	7
ID	s	76	8	0x556ce6fac450
LBRACKET	[	76	9
DECIMAL	0	76	10	0
RBRACKET	]	76	11
RBRACKET	]	76	12
SEMICOLON	;	76	13
RBRACE	}	77	0
INT	int	79	0
ID	stack_size	79	3	0x556ce6fac518
LPAREN	(	79	13
INT	int	79	14
ID	s	79	17	0x556ce6fac450
LBRACKET	[	79	18
RBRACKET	]	79	19
RPAREN	)	79	20
LBRACE	{	79	21
RETURN	return	80	0
ID	s	80	6	0x556ce6fac450
LBRACKET	[	80	7
DECIMAL	0	80	8	0
RBRACKET	]	80	9
SEMICOLON	;	80	10
RBRACE	}	81	0
INT	int	83	0
ID	eval_op	83	3	0x556ce6fac540
LPAREN	(	83	10
INT	int	83	11
ID	op	83	14	0x556ce6fac400
COMMA	,	83	16
INT	int	83	17
ID	lhs	83	20	0x556ce6fac568
COMMA	,	83	23
INT	int	83	24
ID	rhs	83	27	0x556ce6fac590
RPAREN	)	83	30
LBRACE	{	83	31
IF	if	85	0
LPAREN	(	85	2
ID	op	85	3	0x556ce6fac400
EQUAL	==	85	5
DECIMAL	43	85	7	43
RPAREN	)	85	9
RETURN	return	85	10
ID	lhs	85	16	0x556ce6fac568
ADD	+	85	19
ID	rhs	85	20	0x556ce6fac590
SEMICOLON	;	85	23
IF	if	87	0
LPAREN	(	87	2
ID	op	87	3	0x556ce6fac400
EQUAL	==	87	5
DECIMAL	45	87	7	45
RPAREN	)	87	9
RETURN	return	87	10
ID	lhs	87	16	0x556ce6fac568
SUB	-	87	19
ID	rhs	87	20	0x556ce6fac590
SEMICOLON	;	87	23
IF	if	89	0
LPAREN	(	89	2
ID	op	89	3	0x556ce6fac400
EQUAL	==	89	5
DECIMAL	42	89	7	42
RPAREN	)	89	9
RETURN	return	89	10
ID	lhs	89	16	0x556ce6fac568
MUL	*	89	19
ID	rhs	89	20	0x556ce6fac590
SEMICOLON	;	89	23
IF	if	91	0
LPAREN	(	91	2
ID	op	91	3	0x556ce6fac400
EQUAL	==	91	5
DECIMAL	47	91	7	47
RPAREN	)	91	9
RETURN	return	91	10
ID	lhs	91	16	0x556ce6fac568
DIV	/	91	19
ID	rhs	91	20	0x556ce6fac590
SEMICOLON	;	91	23
IF	if	93	0
LPAREN	(	93	2
ID	op	93	3	0x556ce6fac400
EQUAL	==	93	5
DECIMAL	37	93	7	37
RPAREN	)	93	9
RETURN	return	93	10
ID	lhs	93	16	0x556ce6fac568
MOD	%	93	19
ID	rhs	93	20	0x556ce6fac590
SEMICOLON	;	93	23
RETURN	return	95	0
DECIMAL	0	95	6	0
SEMICOLON	;	95	7
RBRACE	}	96	0
INT	int	98	0
ID	eval	98	3	0x556ce6fac5b8
LPAREN	(	98	7
RPAREN	)	98	8
LBRACE	{	98	9
INT	int	99	0
ID	oprs	99	3	0x556ce6fac5e0
LBRACKET	[	99	7
DECIMAL	256	99	8	256
RBRACKET	]	99	11
ASSIGN	=	99	12
LBRACE	{	99	13
RBRACE	}	99	14
COMMA	,	99	15
ID	ops	99	16	0x556ce6fac608
LBRACKET	[	99	19
DECIMAL	256	99	20	256
RBRACKET	]	99	23
ASSIGN	=	99	24
LBRACE	{	99	25
RBRACE	}	99	26
SEMICOLON	;	99	27
IF	if	101	0
LPAREN	(	101	2
ID	cur_token	101	3	0x556ce6fac270
NEQUAL	!=	101	12
ID	TOKEN_NUM	101	14	0x556ce6fac1a8
RPAREN	)	101	23
RETURN	return	101	24
ID	panic	101	30	0x556ce6fac388
LPAREN	(	101	35
RPAREN	)	101	36
SEMICOLON	;	101	37
ID	stack_push	102	0	0x556ce6fac428
LPAREN	(	102	10
ID	oprs	102	11	0x556ce6fac5e0
COMMA	,	102	15
ID	num	102	16	0x556ce6fac220
RPAREN	)	102	19
SEMICOLON	;	102	20
ID	next_token	103	0	0x556ce6fac360
LPAREN	(	103	10
RPAREN	)	103	11
SEMICOLON	;	103	12
WHILE	while	105	0
LPAREN	(	105	5
ID	cur_token	105	6	0x556ce6fac270
EQUAL	==	105	15
ID	TOKEN_OTHER	105	17	0x556ce6fac1d0
RPAREN	)	105	28
LBRACE	{	105	29
INT	int	107	0
ID	op	107	3	0x556ce6fac400
ASSIGN	=	107	5
ID	other	107	6	0x556ce6fac248
SEMICOLON	;	107	11
IF	if	108	0
LPAREN	(	108	2
NOT	!	108	3
ID	get_op_prec	108	4	0x556ce6fac3d8
LPAREN	(	108	15
ID	op	108	16	0x556ce6fac400
RPAREN	)	108	18
RPAREN	)	108	19
BREAK	break	108	20
SEMICOLON	;	108	25
ID	next_token	109	0	0x556ce6fac360
LPAREN	(	109	10
RPAREN	)	109	11
SEMICOLON	;	109	12
WHILE	while	111	0
LPAREN	(	111	5
ID	stack_size	111	6	0x556ce6fac518
LPAREN	(	111	16
ID	ops	111	17	0x556ce6fac608
RPAREN	)	111	20
AND	&&	111	21
ID	get_op_prec	111	23	0x556ce6fac3d8
LPAREN	(	111	34
ID	stack_peek	111	35	0x556ce6fac4f0
LPAREN	(	111	45
ID	ops	111	46	0x556ce6fac608
RPAREN	)	111	49
RPAREN	)	111	50
GEQUAL	>=	111	51
ID	get_op_prec	111	53	0x556ce6fac3d8
LPAREN	(	111	64
ID	op	111	65	0x556ce6fac400
RPAREN	)	111	67
RPAREN	)	111	68
LBRACE	{	111	69
INT	int	113	0
ID	cur_op	113	3	0x556ce6fac630
ASSIGN	=	113	9
ID	stack_pop	113	10	0x556ce6fac4a0
LPAREN	(	113	19
ID	ops	113	20	0x556ce6fac608
RPAREN	)	113	23
SEMICOLON	;	113	24
INT	int	114	0
ID	rhs	114	3	0x556ce6fac590
ASSIGN	=	114	6
ID	stack_pop	114	7	0x556ce6fac4a0
LPAREN	(	114	16
ID	oprs	114	17	0x556ce6fac5e0
RPAREN	)	114	21
COMMA	,	114	22
ID	lhs	114	23	0x556ce6fac568
ASSIGN	=	114	26
ID	stack_pop	114	27	0x556ce6fac4a0
LPAREN	(	114	36
ID	oprs	114	37	0x556ce6fac5e0
RPAREN	)	114	41
SEMICOLON	;	114	42
ID	stack_push	115	0	0x556ce6fac428
LPAREN	(	115	10
ID	oprs	115	11	0x556ce6fac5e0
COMMA	,	115	15
ID	eval_op	115	16	0x556ce6fac540
LPAREN	(	115	23
ID	cur_op	115	24	0x556ce6fac630
COMMA	,	115	30
ID	lhs	115	31	0x556ce6fac568
COMMA	,	115	34
ID	rhs	115	35	0x556ce6fac590
RPAREN	)	115	38
RPAREN	)	115	39
SEMICOLON	;	115	40
RBRACE	}	116	0
ID	stack_push	117	0	0x556ce6fac428
LPAREN	(	117	10
ID	ops	117	11	0x556ce6fac608
COMMA	,	117	14
ID	op	117	15	0x556ce6fac400
RPAREN	)	117	17
SEMICOLON	;	117	18
IF	if	119	0
LPAREN	(	119	2
ID	cur_token	119	3	0x556ce6fac270
NEQUAL	!=	119	12
ID	TOKEN_NUM	119	14	0x556ce6fac1a8
RPAREN	)	119	23
RETURN	return	119	24
ID	panic	119	30	0x556ce6fac388
LPAREN	(	119	35
RPAREN	)	119	36
SEMICOLON	;	119	37
ID	stack_push	120	0	0x556ce6fac428
LPAREN	(	120	10
ID	oprs	120	11	0x556ce6fac5e0
COMMA	,	120	15
ID	num	120	16	0x556ce6fac220
RPAREN	)	120	19
SEMICOLON	;	120	20
ID	next_token	121	0	0x556ce6fac360
LPAREN	(	121	10
RPAREN	)	121	11
SEMICOLON	;	121	12
RBRACE	}	122	0
ID	next_token	124	0	0x556ce6fac360
LPAREN	(	124	10
RPAREN	)	124	11
SEMICOLON	;	124	12
WHILE	while	126	0
LPAREN	(	126	5
ID	stack_size	126	6	0x556ce6fac518
LPAREN	(	126	16
ID	ops	126	17	0x556ce6fac608
RPAREN	)	126	20
RPAREN	)	126	21
LBRACE	{	126	22
INT	int	127	0
ID	cur_op	127	3	0x556ce6fac630
ASSIGN	=	127	9
ID	stack_pop	127	10	0x556ce6fac4a0
LPAREN	(	127	19
ID	ops	127	20	0x556ce6fac608
RPAREN	)	127	23
SEMICOLON	;	127	24
INT	int	128	0
ID	rhs	128	3	0x556ce6fac590
ASSIGN	=	128	6
ID	stack_pop	128	7	0x556ce6fac4a0
LPAREN	(	128	16
ID	oprs	128	17	0x556ce6fac5e0
RPAREN	)	128	21
COMMA	,	128	22
ID	lhs	128	23	0x556ce6fac568
ASSIGN	=	128	26
ID	stack_pop	128	27	0x556ce6fac4a0
LPAREN	(	128	36
ID	oprs	128	37	0x556ce6fac5e0
RPAREN	)	128	41
SEMICOLON	;	128	42
ID	stack_push	129	0	0x556ce6fac428
LPAREN	(	129	10
ID	oprs	129	11	0x556ce6fac5e0
COMMA	,	129	15
ID	eval_op	129	16	0x556ce6fac540
LPAREN	(	129	23
ID	cur_op	129	24	0x556ce6fac630
COMMA	,	129	30
ID	lhs	129	31	0x556ce6fac568
COMMA	,	129	34
ID	rhs	129	35	0x556ce6fac590
RPAREN	)	129	38
RPAREN	)	129	39
SEMICOLON	;	129	40
RBRACE	}	130	0
RETURN	return	131	0
ID	stack_peek	131	6	0x556ce6fac4f0
LPAREN	(	131	16
ID	oprs	131	17	0x556ce6fac5e0
RPAREN	)	131	21
SEMICOLON	;	131	22
RBRACE	}	132	0
INT	int	134	0
ID	main	134	3	0x556ce6fac658
LPAREN	(	134	7
RPAREN	)	134	8
LBRACE	{	134	9
INT	int	135	0
ID	count	135	3	0x556ce6fac680
ASSIGN	=	135	8
ID	getint	135	9	0x556ce6fac6a8
LPAREN	(	135	15
RPAREN	)	135	16
SEMICOLON	;	135	17
ID	getch	136	0	0x556ce6fac2c0
LPAREN	(	136	5
RPAREN	)	136	6
SEMICOLON	;	136	7
ID	next_token	137	0	0x556ce6fac360
LPAREN	(	137	10
RPAREN	)	137	11
SEMICOLON	;	137	12
WHILE	while	138	0
LPAREN	(	138	5
ID	count	138	6	0x556ce6fac680
RPAREN	)	138	11
LBRACE	{	138	12
ID	putint	139	0	0x556ce6fac6d0
LPAREN	(	139	6
ID	eval	139	7	0x556ce6fac5b8
LPAREN	(	139	11
RPAREN	)	139	12
RPAREN	)	139	13
SEMICOLON	;	139	14
ID	putch	140	0	0x556ce6fac3b0
LPAREN	(	140	5
DECIMAL	10	140	6	10
RPAREN	)	140	8
SEMICOLON	;	140	9
ID	count	141	0	0x556ce6fac680
ASSIGN	=	141	5
ID	count	141	6	0x556ce6fac680
SUB	-	141	11
DECIMAL	1	141	12	1
SEMICOLON	;	141	13
RBRACE	}	142	0
RETURN	return	143	0
DECIMAL	0	143	6	0
SEMICOLON	;	143	7
RBRACE	}	144	0
